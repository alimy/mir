[{"id":0,"href":"/mir/en/docs/quick-start/","title":"Quck Start","section":"Docs","content":" Mir A cool help tool to develop RESTful API. Mir is a toolkit to develop RESTful API backend service like develop service of gRPC. It adapt some HTTP framework sush as Gin, Chi, Hertz, Echo, Iris, Fiber, Macaron, Mux, httprouterã€‚\nGenerate a simple template project # % go install github.com/alimy/mir/mirc/v5@latest % mirc new -h create template project Usage: mirc new [flags] Flags: -d, --dst string genereted destination target directory (default \u0026#34;.\u0026#34;) -h, --help help for new --mir string mir replace package name or place -p, --pkg string project\u0026#39;s package name (default \u0026#34;github.com/alimy/mir-example\u0026#34;) -s, --style string generated engine style eg: gin,chi,mux,hertz,echo,iris,fiber,fiber-v2,macaron,httprouter (default \u0026#34;gin\u0026#34;) % mirc new -d example % tree example example . |-- Makefile |-- README.md |-- go.mod |-- go.sum |-- main.go |-- mirc | |-- auto | | `-- api | | |-- site.go | | |-- v1 | | | `-- site.go | | `-- v2 | | `-- site.go | |-- gen.go | `-- routes | |-- site.go | |-- v1 | | `-- site.go | `-- v2 | `-- site.go `-- servants |-- core.go |-- servants.go |-- site.go |-- site_v1.go `-- site_v2.go % cd example % make generate % make run RESTful API define: # // file: mirc/routes.go package routes import ( . \u0026#34;github.com/alimy/mir/v5\u0026#34; ) type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } // User user interface info type User struct { Schema `mir:\u0026#34;v1,chain\u0026#34;` Login func(Post, LoginReq) LoginResp `mir:\u0026#34;/login/\u0026#34;` Logout func(Post) `mir:\u0026#34;/logout/\u0026#34;` } Stub source code generatee automatic: // file: mirc/auto/api/routes.go // Code generated by go-mir. DO NOT EDIT. // versions: // - mir v5.2 package routes import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type _binding_ interface { Bind(*gin.Context) error } type _render_ interface { Render(*gin.Context) } type _default_ interface { Bind(*gin.Context, any) error Render(*gin.Context, any, error) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } type User interface { _default_ // Chain provide handlers chain for gin Chain() gin.HandlersChain Login(*gin.Context, *LoginReq) (*LoginResp, error) Logout(*gin.Context) error mustEmbedUnimplementedUserServant() } // UnimplementedUserServant can be embedded to have forward compatible implementations. type UnimplementedUserServant struct { } // RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) // register routes info to router router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/login/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } req := new(LoginReq) if err := s.Bind(c, req); err != nil { s.Render(c, nil, err) return } resp, err := s.Login(req) s.Render(c, resp, err) }) router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/logout/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } r.Render(c, nil, s.Logout(c)) }) } func (UnimplementedUserServant) Chain() gin.HandlersChain { return nil } func (UnimplementedUserServant) Login(c *gin.Context, req *LoginReq) (*LoginResp, error) { return nil, mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) Logout(c *gin.Context) error { return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) mustEmbedUnimplementedUserServant() {} API interface implement: # // file: servants/user.go package servants import ( \u0026#34;github.com/alimy/mir-example/v5/mirc/auto/api\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type baseSrv struct{} func (baseSrv) Bind(c *gin.Context, obj any) error { if err := c.ShouldBind(obj); err != nil { mir.NewError(http.StatusBadRequest, err) } return nil } func (baseSrv) Render(c *gin.Context, data any, err error) { if err == nil { c.JSON(http.StatusOK, data) } else if code, ok := mir.HttpStatusCode(err); ok { c.JSON(code, err.Error()) } else { c.JSON(http.StatusInternalServer, err.Error()) } } type userSrv struct { baseSrv api.UnimplementedUserServant } func newUserSrv() api.Site { return \u0026amp;userSrv{} } Service register: # // file: servants/servants.go package servants import ( \u0026#34;github.com/alimy/mir-example/v5/mirc/auto/api\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // RegisterServants register all the servants to gin.Engine func RegisterServants(e *gin.Engine) { api.RegisterUserServant(e, newUserSrv()) // TODO: some other servant to register } App start: # // file: main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/alimy/mir-example/v5/servants\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { e := gin.Default() // register servants to gin servants.RegisterServants(e) // start servant service if err := e.Run(); err != nil { log.Fatal(err) } } "},{"id":1,"href":"/mir/en/docs/recommends/","title":"Recommends","section":"Docs","content":" Yesql - ðŸ”¥a help tool for develop database logic that use sqlx. paopao-ce - ðŸ”¥an artistic \u0026ldquo;twitter like\u0026rdquo; community built on gin+zinc+vue+ts. "},{"id":2,"href":"/mir/en/docs/tutorials/generate-template-project/","title":"Generate Template Project","section":"Turotials","content":" Generate Template Project # % go install github.com/alimy/mir/mirc/v5@latest % mirc new -h create template project Usage: mirc new [flags] Flags: -d, --dst string genereted destination target directory (default \u0026#34;.\u0026#34;) -h, --help help for new --mir string mir replace package name or place -p, --pkg string project\u0026#39;s package name (default \u0026#34;github.com/alimy/mir-example\u0026#34;) -s, --style string generated engine style eg: gin,chi,mux,hertz,echo,iris,fiber,fiber-v2,macaron,httprouter (default \u0026#34;gin\u0026#34;) % mirc new -d example % tree example example . |-- Makefile |-- README.md |-- go.mod |-- go.sum |-- main.go |-- mirc | |-- auto | | `-- api | | |-- site.go | | |-- v1 | | | `-- site.go | | `-- v2 | | `-- site.go | |-- gen.go | `-- routes | |-- site.go | |-- v1 | | `-- site.go | `-- v2 | `-- site.go `-- servants |-- core.go |-- servants.go |-- site.go |-- site_v1.go `-- site_v2.go % cd example % make generate % make run "},{"id":3,"href":"/mir/en/docs/tutorials/interface-define/","title":"Interface Define","section":"Turotials","content":" Interface Define # // file: mirc/routes.go package routes import ( . \u0026#34;github.com/alimy/mir/v5\u0026#34; ) type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } // User user interface info type User struct { Schema `mir:\u0026#34;v1,chain\u0026#34;` Login func(Post, LoginReq) LoginResp `mir:\u0026#34;/login/\u0026#34;` Logout func(Post) `mir:\u0026#34;/logout/\u0026#34;` } "},{"id":4,"href":"/mir/en/docs/tutorials/code-generate/","title":"Code Generate","section":"Turotials","content":" Code Generate # // file: mirc/auto/api/v1/user.go // Code generated by go-mir. DO NOT EDIT. // versions: // - mir 5.2 package v1 import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type _binding_ interface { Bind(*gin.Context) error } type _render_ interface { Render(*gin.Context) } type _default_ interface { Bind(*gin.Context, any) error Render(*gin.Context, any, error) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } type User interface { _default_ // Chain provide handlers chain for gin Chain() gin.HandlersChain Logout() error Login(*LoginReq) (*LoginResp, error) mustEmbedUnimplementedUserServant() } // RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) // register routes info to router router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/logout/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } s.Render(c, nil, s.Logout()) }) router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/login/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } req := new(LoginReq) if err := s.Bind(c, req); err != nil { s.Render(c, nil, err) return } resp, err := s.Login(req) s.Render(c, resp, err) }) } // UnimplementedUserServant can be embedded to have forward compatible implementations. type UnimplementedUserServant struct{} func (UnimplementedUserServant) Chain() gin.HandlersChain { return nil } func (UnimplementedUserServant) Logout() error { return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) Login(req *LoginReq) (*LoginResp, error) { return nil, mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) mustEmbedUnimplementedUserServant() {} "},{"id":5,"href":"/mir/en/docs/tutorials/servant-implement/","title":"Servant Implement","section":"Turotials","content":" Servant Implement: # // file: servants/user.go package servants import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; api \u0026#34;github.com/alimy/mir-example/v5/mirc/auto/api/v1\u0026#34; ) type baseSrv struct{} func (baseSrv) Bind(c *gin.Context, obj any) error { if err := c.ShouldBind(obj); err != nil { mir.NewError(http.StatusBadRequest, err) } return nil } func (baseSrv) Render(c *gin.Context, data any, err error) { if err == nil { c.JSON(http.StatusOK, data) } else if code, ok := mir.HttpStatusCode(err); ok { c.JSON(code, err.Error()) } else { c.JSON(http.StatusInternalServer, err.Error()) } } type userSrv struct { baseSrv api.UnimplementedUserServant } func newUserSrv() api.Site { return \u0026amp;userSrv{} } "},{"id":6,"href":"/mir/en/docs/tutorials/servant-register/","title":"Servant Register","section":"Turotials","content":" Servant Register: # // file: servants/servants.go package servants import ( api \u0026#34;github.com/alimy/mir-example/v4/mirc/auto/api/v1\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // RegisterServants register all the servants to gin.Engine func RegisterServants(e *gin.Engine) { api.RegisterUserServant(e, newUserSrv()) // TODO: some other servant to register } "},{"id":7,"href":"/mir/en/docs/tutorials/app-start/","title":"App Start","section":"Turotials","content":" App Start: # // file: main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/alimy/mir-example/v4/servants\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { e := gin.Default() // register servants to gin servants.RegisterServants(e) // start servant service if err := e.Run(); err != nil { log.Fatal(err) } } "},{"id":8,"href":"/mir/en/docs/quick-start/projects-use-go-mir/","title":"Projects That Use go-mir","section":"Quck Start","content":" Projects That Use go-mir # examples - a demo example to describe how to use Mir to develop RESTful API backend service quickly. paopao-ce - A artistic \u0026ldquo;twitter like\u0026rdquo; community built on gin+zinc+vue+ts. "}]