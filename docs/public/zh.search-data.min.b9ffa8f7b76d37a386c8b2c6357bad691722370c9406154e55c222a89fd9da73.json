[{"id":0,"href":"/mir/docs/quck-start/","title":"å¿«é€Ÿå¼€å§‹","section":"Docs","content":" Mir ä¸€ä¸ªå¾ˆé…·çš„å¼€å‘RESTful APIçš„è¾…åŠ©å·¥å…· Mir æ˜¯ä¸€å¥—æä¾›ç±»ä¼¼gRPCæœåŠ¡å¼€å‘ä½“éªŒçš„å¿«é€Ÿå¼€å‘RESTful APIåç«¯å¼€å‘è„šæ‰‹æ¶ï¼Œé€‚é…å¤šç§HTTPæ¡†æ¶ï¼ŒåŒ…æ‹¬ Gin, Chi, Hertz, Echo, Iris, Fiber, Macaron, Mux, httprouterã€‚\nç”Ÿæˆæ ·æ¿é¡¹ç›® # % go install github.com/alimy/mir/mirc/v4@latest % mirc new -h create template project Usage: mirc new [flags] Flags: -d, --dst string genereted destination target directory (default \u0026#34;.\u0026#34;) -h, --help help for new --mir string mir replace package name or place -p, --pkg string project\u0026#39;s package name (default \u0026#34;github.com/alimy/mir-example\u0026#34;) -s, --style string generated engine style eg: gin,chi,mux,hertz,echo,iris,fiber,fiber-v2,macaron,httprouter (default \u0026#34;gin\u0026#34;) % mirc new -d example % tree example example . |-- Makefile |-- README.md |-- go.mod |-- go.sum |-- main.go |-- mirc | |-- auto | | `-- api | | |-- site.go | | |-- v1 | | | `-- site.go | | `-- v2 | | `-- site.go | |-- gen.go | `-- routes | |-- site.go | |-- v1 | | `-- site.go | `-- v2 | `-- site.go `-- servants |-- core.go |-- servants.go |-- site.go |-- site_v1.go `-- site_v2.go % cd example % make generate % make run RESTfulæ¥å£å®šä¹‰: # // file: mirc/routes.go package routes import ( . \u0026#34;github.com/alimy/mir/v5\u0026#34; . \u0026#34;github.com/alimy/mir/v5/engine\u0026#34; ) func init() { AddEntry(new(User)) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } // User user interface info type User struct { Chain `mir:\u0026#34;-\u0026#34;` Group `mir:\u0026#34;v1\u0026#34;` Login func(Post, LoginReq) LoginResp `mir:\u0026#34;/login/\u0026#34;` Logout func(Post) `mir:\u0026#34;/logout/\u0026#34;` } ä»£ç ç”Ÿæˆ: # // file: mirc/auto/api/routes.go // Code generated by go-mir. DO NOT EDIT. // versions: // - mir v4.0.0 package routes import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type _binding_ interface { Bind(*gin.Context) mir.Error } type _render_ interface { Render(*gin.Context) } type _default_ interface { Bind(*gin.Context, any) mir.Error Render(*gin.Context, any, mir.Error) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } type User interface { _default_ // Chain provide handlers chain for gin Chain() gin.HandlersChain Login(*gin.Context, *LoginReq) (*LoginResp, mir.Error) Logout(*gin.Context) mir.Error mustEmbedUnimplementedUserServant() } // RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) // register routes info to router router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/login/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } req := new(LoginReq) if err := s.Bind(c, req); err != nil { s.Render(c, nil, err) return } resp, err := s.Login(req) s.Render(c, resp, err) }) router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/logout/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } s.Render(c, nil, s.Logout(c)) }) } func (UnimplementedUserServant) Chain() gin.HandlersChain { return nil } func (UnimplementedUserServant) Login(c *gin.Context, req *LoginReq) (*LoginResp, mir.Error) { return nil, mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) Logout(c *gin.Context) mir.Error { return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) mustEmbedUnimplementedUserServant() {} æ¥å£å®ç°: # // file: servants/user.go package servants import ( \u0026#34;github.com/alimy/mir-example/v4/mirc/auto/api\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type baseSrv struct{} func (baseSrv) Bind(c *gin.Context, obj any) mir.Error { if err := c.ShouldBind(obj); err != nil { mir.NewError(http.StatusBadRequest, err) } return nil } func (baseSrv) Render(c *gin.Context, data any, err mir.Error) { if err == nil { c.JSON(http.StatusOK, data) } else { c.JSON(err.StatusCode(), err.Error()) } } type userSrv struct { baseSrv api.UnimplementedUserServant } func newUserSrv() api.Site { return \u0026amp;userSrv{} } æœåŠ¡æ³¨å†Œ: # // file: servants/servants.go package servants import ( \u0026#34;github.com/alimy/mir-example/v4/mirc/auto/api\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // RegisterServants register all the servants to gin.Engine func RegisterServants(e *gin.Engine) { api.RegisterUserServant(e, newUserSrv()) // TODO: some other servant to register } ç¨‹åºå¯åŠ¨: # // file: main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/alimy/mir-example/v4/servants\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { e := gin.Default() // register servants to gin servants.RegisterServants(e) // start servant service if err := e.Run(); err != nil { log.Fatal(err) } } "},{"id":1,"href":"/mir/docs/recommends/","title":"æ¨èé¡¹ç›®","section":"Docs","content":" Yesql - ğŸ”¥ä¸€ä¸ªç”¨äºä½¿ç”¨ sqlxæ¥å¼€å‘æ•°æ®ä¸šåŠ¡é€»è¾‘çš„è¾…åŠ©åº“. paopao-ce - ğŸ”¥ä¸€ä¸ªæ¸…æ–°æ–‡è‰ºçš„å¾®ç¤¾åŒº. "},{"id":2,"href":"/mir/docs/tutorials/generate-template-project/","title":"ç”Ÿæˆæ ·æ¿é¡¹ç›®","section":"ä½¿ç”¨æŒ‡å—","content":" ç”Ÿæˆæ ·æ¿é¡¹ç›® # % go get github.com/alimy/mir/mirc/v4@latest % mirc new -h create template project Usage: mirc new [flags] Flags: -d, --dst string genereted destination target directory (default \u0026#34;.\u0026#34;) -h, --help help for new --mir string mir replace package name or place -p, --pkg string project\u0026#39;s package name (default \u0026#34;github.com/alimy/mir-example\u0026#34;) -s, --style string generated engine style eg: gin,chi,mux,hertz,echo,iris,fiber,fiber-v2,macaron,httprouter (default \u0026#34;gin\u0026#34;) % mirc new -d example % tree example example . |-- Makefile |-- README.md |-- go.mod |-- go.sum |-- main.go |-- mirc | |-- auto | | `-- api | | |-- site.go | | |-- v1 | | | `-- site.go | | `-- v2 | | `-- site.go | |-- gen.go | `-- routes | |-- site.go | |-- v1 | | `-- site.go | `-- v2 | `-- site.go `-- servants |-- core.go |-- servants.go |-- site.go |-- site_v1.go `-- site_v2.go % cd example % make generate % make build "},{"id":3,"href":"/mir/docs/tutorials/interface-define/","title":"æ¥å£å®šä¹‰","section":"ä½¿ç”¨æŒ‡å—","content":" æ¥å£å®šä¹‰ # // file: mirc/routes.go package routes import ( . \u0026#34;github.com/alimy/mir/v5\u0026#34; . \u0026#34;github.com/alimy/mir/v5/engine\u0026#34; ) func init() { AddEntry(new(User)) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } // User user interface info type User struct { Chain Chain `mir:\u0026#34;-\u0026#34;` Group Group `mir:\u0026#34;v1\u0026#34;` Login func(Post, LoginReq) LoginResp `mir:\u0026#34;/login/\u0026#34;` Logout func(Post) `mir:\u0026#34;/logout/\u0026#34;` } å¦‚ä¸Šç¤ºä¾‹ï¼Œfile:mirc/routes.goæ–‡ä»¶å®šä¹‰äº†User RESTful APIæ¥å£ï¼Œç®€è¦è¯´æ˜Mirçš„æ¥å£æ˜¯å¦‚ä½•å®šä¹‰ï¼š\nä¸€ä¸ªç‹¬ç«‹çš„æ¥å£é›†åˆæ˜¯å®šä¹‰åœ¨Golangçš„ç»“æ„ä½“structä¸­çš„ï¼Œstructçš„åå­—å°†æ˜¯æ¥å£é›†åˆçš„åå­—ï¼›å®šä¹‰åçš„æ¥å£éœ€è¦é€šè¿‡mir.AddEntry(any)æ³¨å†Œåˆ°Mirä¸­ä»¥ä¾›æœåŠ¡æ¥å£ä»£ç çš„è‡ªåŠ¨ç”Ÿæˆï¼›æ¯”å¦‚è¿™é‡Œçš„Userå°±æ˜¯ä¸€ä¸ªRESTful APIçš„é›†åˆï¼Œå®šä¹‰åçš„æ¥å£ä¿¡æ¯é€šè¿‡init()ä¸­çš„AddEntry(new(User))æ³¨å†Œåˆ°Mirä¸­ï¼Œåœ¨Mirè‡ªåŠ¨ç”ŸæˆæœåŠ¡æ¥å£ä»£ç çš„æ—¶å€™å°†æ ¹æ®Userä¸­åŒ…å«çš„ä¿¡æ¯è‡ªåŠ¨ç”ŸæˆæœåŠ¡æ¥å£ä»£ç ï¼› æ¥å£å®šä¹‰çš„ç»“æ„ä½“structä¸­ï¼Œæ¯ä¸ªFieldéƒ½æœ‰ç‰¹æ®Šæ„ä¹‰: Fieldåå­—è¡¨ç¤ºè¿™ä¸ªæœåŠ¡æ¥å£è‡ªåŠ¨ç”Ÿæˆä»£ç çš„æ–¹æ³•åå­—ï¼› Fieldä¸­çš„struct tag mir å®šä¹‰çš„æ˜¯æ¥å£å°†æ³¨å†Œçš„è·¯ç”±urlï¼›\nå¦‚ä¸Šç¤ºä¾‹çš„Loginæ¥å£å°†ç”Ÿæˆå¦‚ä¸‹ä»£ç : // RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User, b UserBinding, r UserRender) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) // register routes info to router router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/login/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } req, err := b.BindLogin(c) if err != nil { r.RenderLogin(c, nil, err) } resp, err := s.Login(c, req) r.RenderLogin(c, resp, err) }) ... } Fieldç±»å‹è¡¨ç¤ºè¿™ä¸ªæ¥å£çš„ç±»å‹ï¼Œç›®å‰æœ‰ä¸‰ç§ï¼šChainã€Groupã€func; Chain è¡¨ç¤ºè¿™ä¸ªæ¥å£é›†åˆéœ€è¦ç”Ÿæˆä¸€ä¸ªè·å–å¯¹åº”HTTPå¼•æ“ä¸­é—´ä»¶çš„æ–¹æ³•ï¼Œæ¯”å¦‚ginå¼•æ“çš„gin.HandlersChain; å¦‚ä¸Šç¤ºä¾‹ï¼Œä½¿ç”¨ginå¼•æ“ä»£ç æ ·å¼çš„ä»£ç ç”Ÿæˆå™¨å°†ç”Ÿæˆå¦‚ä¸‹æ–¹æ³•:\ntype User interface { // Chain provide handlers chain for gin Chain() gin.HandlersChain ... } Group è¡¨ç¤ºè¿™æ˜¯å…¶åé¢çš„struct tagä¸­çš„ç”±miræ ‡è¯†çš„è·¯å¾„æ˜¯è¿™ä¸ªæ¥å£çš„URLå‰ç¼€/ç»„ä¿¡æ¯ï¼›å¦‚ä¸Šç¤ºä¾‹ï¼Œä½¿ç”¨ginå¼•æ“ä»£ç æ ·å¼çš„ä»£ç ç”Ÿæˆå™¨å°†ç”Ÿæˆå¦‚ä¸‹æ³¨å†ŒæœåŠ¡æ–¹æ³•:\n// RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User, b UserBinding, r UserRender) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) ... } func(...)... è¡¨ç¤ºæ¥å£çš„æ–¹æ³•å®šä¹‰ï¼›å‡½æ•°ä¸­çš„å‚æ•°ä¸è¿”å›å€¼æœ‰ç€ç‰¹æ®Šæ„ä¹‰:\nå‡½æ•°å¯ä»¥æœ‰å¤šä¸ªå‚æ•°ï¼Œä¹Ÿå¯æ— å‚æ•°ï¼Œæ— å‚æ•°æ—¶è¡¨ç¤ºå°†è¿™ä¸ªæ¥å£æ³¨å†Œä¸ºæ‰€æœ‰HTTP Method handler; å‡½æ•°å‚æ•°çš„ç±»å‹é™å®šä¸º mir.(Get/Put/Post/Delete/Head/Patch/Trace/Connect/Options/Any/Chain/Context)ç±»å‹ã€Go structç±»å‹ï¼› Go structç±»å‹ä½œä¸ºå‡½æ•°å‚æ•°åªèƒ½æ”¾ç½®åœ¨æœ€åä¸€ä¸ªå‚æ•°ä½ç½®ï¼Œè¡¨ç¤ºæ¥å£éœ€è¦è¿™ä¸ªstructç±»å‹è¡¨ç¤ºçš„å‚æ•°ç±»å‹çš„ä»http requestä¸­Bindingåçš„ç»“æœå¯¹è±¡ä½œä¸ºè¯·æ±‚å‚æ•°ï¼› å‡½æ•°å‚æ•°ä¸­çš„éæœ€åä¸€ä¸ªå‚æ•°ï¼Œå¯ä»¥æœ‰å¤šä¸ªï¼Œç±»å‹é™å®šä¸ºmir.(Get/Put/Post/Delete/Head/Patch/Trace/Connect/Options/Any)ç±»å‹ï¼›è¡¨ç¤ºçš„æ„æ€æ˜¯è¿™ä¸ªæ¥å£å°†æ³¨å†Œä¸ºç›¸åº”çš„HTTP Method handlerï¼Œæ¯”å¦‚mir.Postè¡¨ç¤ºå°†è¿™ä¸ªæ¥å£æ³¨å†Œä¸º HTTP Method ä¸ºPOST çš„handler router.Handle(\u0026quot;POST\u0026quot;, \u0026quot;/login/\u0026quot;, func(...){...}); mir.Any è¡¨ç¤ºå°†è¿™ä¸ªæ¥å£æ³¨å†Œä¸ºæ‰€æœ‰HTTP Method handler; å‡½æ•°å‚æ•°ä¸­å¦‚æœæœ‰Chainè¡¨ç¤ºè¿™ä¸ªæ¥å£æœ‰è‡ªå®šä¹‰çš„HTTPå¼•æ“ä¸­é—´ä»¶çš„æ–¹æ³•ï¼Œæ¯”å¦‚ginå¼•æ“çš„gin.HandlersChainï¼Œä¼šä¸æ¥å£ä¸€èµ·æ³¨å†Œï¼Œç›®å‰ä»…æ”¯æŒGin/Chi/Echo/Hertz/Iriså¼•æ“ï¼› å‡½æ•°è¿”å›å€¼è‡³å¤šåªæœ‰ä¸€ä¸ªï¼Œå¯ä»¥æ²¡æœ‰ï¼Œä¹Ÿå¯ä»¥æœ‰ä¸€ä¸ªï¼Œé™å®šç±»å‹ä¸ºGo structç±»å‹ï¼› å‡½æ•°ä¸­çš„æœ€åä¸€ä¸ªå‚æ•°å’Œè¿”å›å€¼ï¼Œå¦‚æœæœ‰çš„è¯ï¼Œé™å®šç±»å‹ä¸ºGo structç±»å‹ï¼Œå¹¶ä¸”å¯ä»¥è¯´ä¸æ¥å£å®šä¹‰çš„åŒä¸€ä¸ªåŒ…ä¸­çš„ç»“æ„ä½“ï¼Œä¹Ÿå¯ä»¥æ˜¯å…¶ä»–åŒ…ä¸­çš„ç»“æ„ä½“ï¼› å¦‚ä¸Šç¤ºä¾‹ï¼Œä½¿ç”¨ginå¼•æ“æ ·å¼ä»£ç ç”Ÿæˆå™¨å°†ç”Ÿæˆå¦‚ä¸‹ä»£ç :\ntype _binding_ interface { Bind(*gin.Context) mir.Error } type _render_ interface { Render(*gin.Context) } type _default_ interface { Bind(*gin.Context, any) mir.Error Render(*gin.Context, any, mir.Error) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } type User interface { _default_ // Chain provide handlers chain for gin Chain() gin.HandlersChain Login(c *gin.Context, req *LoginReq) (*LoginResp, mir.Error) Logout(c *gin.Context) mir.Error mustEmbedUnimplementedUserServant() } "},{"id":4,"href":"/mir/docs/tutorials/code-generate/","title":"ä»£ç ç”Ÿæˆ","section":"ä½¿ç”¨æŒ‡å—","content":" ä»£ç ç”Ÿæˆ # // file: mirc/auto/api/routes.go // Code generated by go-mir. DO NOT EDIT. // versions: // - mir v3.1.1 package routes import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } type User interface { // Chain provide handlers chain for gin Chain() gin.HandlersChain Login(c *gin.Context, req *LoginReq) (*LoginResp, mir.Error) Logout(c *gin.Context) mir.Error mustEmbedUnimplementedUserServant() } type UserBinding interface { BindLogin(c *gin.Context) (*LoginReq, mir.Error) mustEmbedUnimplementedUserBinding() } type UserRender interface { RenderLogin(c *gin.Context, data *LoginResp, err mir.Error) RenderLogout(c *gin.Context, err mir.Error) mustEmbedUnimplementedUserRender() } // UnimplementedUserServant can be embedded to have forward compatible implementations. type UnimplementedUserServant struct { } // UnimplementedSiteBinding can be embedded to have forward compatible implementations. type UnimplementedSiteBinding struct { BindAny func(*gin.Context, any) mir.Error } // UnimplementedSiteRender can be embedded to have forward compatible implementations. type UnimplementedSiteRender struct { RenderAny func(*gin.Context, any, mir.Error) } // RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User, b UserBinding, r UserRender) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) // register routes info to router router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/login/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } req, err := b.BindLogin(c) if err != nil { r.RenderLogin(c, nil, err) } resp, err := s.Login(c, req) r.RenderLogin(c, resp, err) }) router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/logout/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } r.RenderLogout(c, s.Logout(c)) }) } func (UnimplementedUserServant) Chain() gin.HandlersChain { return nil } func (UnimplementedUserServant) Login(c *gin.Context, req *LoginReq) (*LoginResp, mir.Error) { return nil, mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) Logout(c *gin.Context) mir.Error { return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) mustEmbedUnimplementedUserServant() {} func (b UnimplementedUserBinding) BindLogin(c *gin.Context) (*LoginReq, mir.Error) { obj := new(LoginReq) err := b.BindAny(c, obj) return obj, err } func (b UnimplementedUserBinding) mustEmbedUnimplementedUserBinding() {} func (r UnimplementedUserRender) RenderLogin(c *gin.Context, data *LoginResp, err mir.Error) { r.RenderAny(c, data, err) } func (r UnimplementedUserRender) RenderLogout(c *gin.Context, err mir.Error) { r.RenderAny(c, nil, err) } func (r UnimplementedUserRender) mustEmbedUnimplementedUserRender() {} "},{"id":5,"href":"/mir/docs/tutorials/servant-implement/","title":"æ¥å£å®ç°","section":"ä½¿ç”¨æŒ‡å—","content":" æ¥å£å®ç° # // file: servants/user.go package servants import ( \u0026#34;github.com/alimy/mir-example/v4/mirc/auto/api\u0026#34; ) type userSrv struct { api.UnimplementedUserServant } type userBinding struct { *api.UnimplementedUserBinding } type userRender struct { *api.UnimplementedUserRender } func newUserSrv() api.Site { return \u0026amp;userSrv{} } func newUserBinding() api.SiteBinding { return \u0026amp;siteBinding{ UnimplementedSiteBinding: \u0026amp;api.UnimplementedSiteBinding{ BindAny: bindAny, }, } } func newUserRender() api.SiteRender { return \u0026amp;siteRender{ UnimplementedSiteRender: \u0026amp;api.UnimplementedSiteRender{ RenderAny: renderAny, }, } } func bindAny(c *gin.Context, obj any) mir.Error { if err != c.ShouldBind(obj); err != nil { return mir.NewError(http.StatusBadRequest, err) } return nil } func renderAny(c *gin.Context, data any, err mir.Error) { if err == nil { c.JSON(http.StatusOK, data) } else { c.JSON(err.StatusCode(), err.Error()) } } "},{"id":6,"href":"/mir/docs/tutorials/servant-register/","title":"æœåŠ¡æ³¨å†Œ","section":"ä½¿ç”¨æŒ‡å—","content":" æœåŠ¡æ³¨å†Œ # // file: servants/servants.go package servants import ( \u0026#34;github.com/alimy/mir-example/v4/mirc/auto/api\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // RegisterServants register all the servants to gin.Engine func RegisterServants(e *gin.Engine) { api.RegisterUserServant(e, newUserSrv(), newUserBinding(), newUserRender()) // TODO: some other servant to register } "},{"id":7,"href":"/mir/docs/tutorials/app-start/","title":"ç¨‹åºå¯åŠ¨","section":"ä½¿ç”¨æŒ‡å—","content":" ç¨‹åºå¯åŠ¨: # // file: main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/alimy/mir-example/v4/servants\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { e := gin.Default() // register servants to gin servants.RegisterServants(e) // start servant service if err := e.Run(); err != nil { log.Fatal(err) } } "},{"id":8,"href":"/mir/docs/quck-start/projects-use-go-mir/","title":"ä½¿ç”¨go-mirçš„é¡¹ç›®","section":"å¿«é€Ÿå¼€å§‹","content":" ä½¿ç”¨go-mirçš„é¡¹ç›® # examples - æœ¬é¡¹ç›®è‡ªå¸¦çš„demoï¼Œä¸»è¦æ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨ Mirå¿«é€Ÿè¿›è¡ŒRESTful APIçš„åç«¯å¼€å‘ã€‚ paopao-ce - ä¸€ä¸ªæ¸…æ–°æ–‡è‰ºçš„å¾®ç¤¾åŒºï¼Œæä¾›ç±»ä¼¼Twiter/å¾®åšçš„æ¨æ–‡åˆ†äº«æœåŠ¡ã€‚ "}]