[{"id":0,"href":"/mir/docs/quck-start/","title":"快速开始","section":"Docs","content":" Mir 一个很酷的开发RESTful API的辅助工具 Mir 是一套提供类似gRPC服务开发体验的快速开发RESTful API后端开发脚手架，适配多种HTTP框架，包括 Gin, Chi, Hertz, Echo, Iris, Fiber, Macaron, Mux, httprouter。\n生成样板项目 # % go install github.com/alimy/mir/mirc/v4@latest % mirc new -h create template project Usage: mirc new [flags] Flags: -d, --dst string genereted destination target directory (default \u0026#34;.\u0026#34;) -h, --help help for new --mir string mir replace package name or place -p, --pkg string project\u0026#39;s package name (default \u0026#34;github.com/alimy/mir-example\u0026#34;) -s, --style string generated engine style eg: gin,chi,mux,hertz,echo,iris,fiber,fiber-v2,macaron,httprouter (default \u0026#34;gin\u0026#34;) % mirc new -d example % tree example example . |-- Makefile |-- README.md |-- go.mod |-- go.sum |-- main.go |-- mirc | |-- auto | | `-- api | | |-- site.go | | |-- v1 | | | `-- site.go | | `-- v2 | | `-- site.go | |-- gen.go | `-- routes | |-- site.go | |-- v1 | | `-- site.go | `-- v2 | `-- site.go `-- servants |-- core.go |-- servants.go |-- site.go |-- site_v1.go `-- site_v2.go % cd example % make generate % make run RESTful接口定义: # // file: mirc/routes.go package routes import ( . \u0026#34;github.com/alimy/mir/v5\u0026#34; . \u0026#34;github.com/alimy/mir/v5/engine\u0026#34; ) func init() { AddEntry(new(User)) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } // User user interface info type User struct { Chain `mir:\u0026#34;-\u0026#34;` Group `mir:\u0026#34;v1\u0026#34;` Login func(Post, LoginReq) LoginResp `mir:\u0026#34;/login/\u0026#34;` Logout func(Post) `mir:\u0026#34;/logout/\u0026#34;` } 代码生成: # // file: mirc/auto/api/routes.go // Code generated by go-mir. DO NOT EDIT. // versions: // - mir v4.0.0 package routes import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type _binding_ interface { Bind(*gin.Context) mir.Error } type _render_ interface { Render(*gin.Context) } type _default_ interface { Bind(*gin.Context, any) mir.Error Render(*gin.Context, any, mir.Error) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } type User interface { _default_ // Chain provide handlers chain for gin Chain() gin.HandlersChain Login(*gin.Context, *LoginReq) (*LoginResp, mir.Error) Logout(*gin.Context) mir.Error mustEmbedUnimplementedUserServant() } // RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) // register routes info to router router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/login/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } req := new(LoginReq) if err := s.Bind(c, req); err != nil { s.Render(c, nil, err) return } resp, err := s.Login(req) s.Render(c, resp, err) }) router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/logout/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } s.Render(c, nil, s.Logout(c)) }) } func (UnimplementedUserServant) Chain() gin.HandlersChain { return nil } func (UnimplementedUserServant) Login(c *gin.Context, req *LoginReq) (*LoginResp, mir.Error) { return nil, mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) Logout(c *gin.Context) mir.Error { return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) mustEmbedUnimplementedUserServant() {} 接口实现: # // file: servants/user.go package servants import ( \u0026#34;github.com/alimy/mir-example/v4/mirc/auto/api\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type baseSrv struct{} func (baseSrv) Bind(c *gin.Context, obj any) mir.Error { if err := c.ShouldBind(obj); err != nil { mir.NewError(http.StatusBadRequest, err) } return nil } func (baseSrv) Render(c *gin.Context, data any, err mir.Error) { if err == nil { c.JSON(http.StatusOK, data) } else { c.JSON(err.StatusCode(), err.Error()) } } type userSrv struct { baseSrv api.UnimplementedUserServant } func newUserSrv() api.Site { return \u0026amp;userSrv{} } 服务注册: # // file: servants/servants.go package servants import ( \u0026#34;github.com/alimy/mir-example/v4/mirc/auto/api\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // RegisterServants register all the servants to gin.Engine func RegisterServants(e *gin.Engine) { api.RegisterUserServant(e, newUserSrv()) // TODO: some other servant to register } 程序启动: # // file: main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/alimy/mir-example/v4/servants\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { e := gin.Default() // register servants to gin servants.RegisterServants(e) // start servant service if err := e.Run(); err != nil { log.Fatal(err) } } "},{"id":1,"href":"/mir/docs/recommends/","title":"推荐项目","section":"Docs","content":" Yesql - 🔥一个用于使用 sqlx来开发数据业务逻辑的辅助库. paopao-ce - 🔥一个清新文艺的微社区. "},{"id":2,"href":"/mir/docs/tutorials/generate-template-project/","title":"生成样板项目","section":"使用指南","content":" 生成样板项目 # % go get github.com/alimy/mir/mirc/v4@latest % mirc new -h create template project Usage: mirc new [flags] Flags: -d, --dst string genereted destination target directory (default \u0026#34;.\u0026#34;) -h, --help help for new --mir string mir replace package name or place -p, --pkg string project\u0026#39;s package name (default \u0026#34;github.com/alimy/mir-example\u0026#34;) -s, --style string generated engine style eg: gin,chi,mux,hertz,echo,iris,fiber,fiber-v2,macaron,httprouter (default \u0026#34;gin\u0026#34;) % mirc new -d example % tree example example . |-- Makefile |-- README.md |-- go.mod |-- go.sum |-- main.go |-- mirc | |-- auto | | `-- api | | |-- site.go | | |-- v1 | | | `-- site.go | | `-- v2 | | `-- site.go | |-- gen.go | `-- routes | |-- site.go | |-- v1 | | `-- site.go | `-- v2 | `-- site.go `-- servants |-- core.go |-- servants.go |-- site.go |-- site_v1.go `-- site_v2.go % cd example % make generate % make build "},{"id":3,"href":"/mir/docs/tutorials/interface-define/","title":"接口定义","section":"使用指南","content":" 接口定义 # // file: mirc/routes.go package routes import ( . \u0026#34;github.com/alimy/mir/v5\u0026#34; . \u0026#34;github.com/alimy/mir/v5/engine\u0026#34; ) func init() { AddEntry(new(User)) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } // User user interface info type User struct { Chain Chain `mir:\u0026#34;-\u0026#34;` Group Group `mir:\u0026#34;v1\u0026#34;` Login func(Post, LoginReq) LoginResp `mir:\u0026#34;/login/\u0026#34;` Logout func(Post) `mir:\u0026#34;/logout/\u0026#34;` } 如上示例，file:mirc/routes.go文件定义了User RESTful API接口，简要说明Mir的接口是如何定义：\n一个独立的接口集合是定义在Golang的结构体struct中的，struct的名字将是接口集合的名字；定义后的接口需要通过mir.AddEntry(any)注册到Mir中以供服务接口代码的自动生成；比如这里的User就是一个RESTful API的集合，定义后的接口信息通过init()中的AddEntry(new(User))注册到Mir中，在Mir自动生成服务接口代码的时候将根据User中包含的信息自动生成服务接口代码； 接口定义的结构体struct中，每个Field都有特殊意义: Field名字表示这个服务接口自动生成代码的方法名字； Field中的struct tag mir 定义的是接口将注册的路由url；\n如上示例的Login接口将生成如下代码: // RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User, b UserBinding, r UserRender) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) // register routes info to router router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/login/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } req, err := b.BindLogin(c) if err != nil { r.RenderLogin(c, nil, err) } resp, err := s.Login(c, req) r.RenderLogin(c, resp, err) }) ... } Field类型表示这个接口的类型，目前有三种：Chain、Group、func; Chain 表示这个接口集合需要生成一个获取对应HTTP引擎中间件的方法，比如gin引擎的gin.HandlersChain; 如上示例，使用gin引擎代码样式的代码生成器将生成如下方法:\ntype User interface { // Chain provide handlers chain for gin Chain() gin.HandlersChain ... } Group 表示这是其后面的struct tag中的由mir标识的路径是这个接口的URL前缀/组信息；如上示例，使用gin引擎代码样式的代码生成器将生成如下注册服务方法:\n// RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User, b UserBinding, r UserRender) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) ... } func(...)... 表示接口的方法定义；函数中的参数与返回值有着特殊意义:\n函数可以有多个参数，也可无参数，无参数时表示将这个接口注册为所有HTTP Method handler; 函数参数的类型限定为 mir.(Get/Put/Post/Delete/Head/Patch/Trace/Connect/Options/Any/Chain/Context)类型、Go struct类型； Go struct类型作为函数参数只能放置在最后一个参数位置，表示接口需要这个struct类型表示的参数类型的从http request中Binding后的结果对象作为请求参数； 函数参数中的非最后一个参数，可以有多个，类型限定为mir.(Get/Put/Post/Delete/Head/Patch/Trace/Connect/Options/Any)类型；表示的意思是这个接口将注册为相应的HTTP Method handler，比如mir.Post表示将这个接口注册为 HTTP Method 为POST 的handler router.Handle(\u0026quot;POST\u0026quot;, \u0026quot;/login/\u0026quot;, func(...){...}); mir.Any 表示将这个接口注册为所有HTTP Method handler; 函数参数中如果有Chain表示这个接口有自定义的HTTP引擎中间件的方法，比如gin引擎的gin.HandlersChain，会与接口一起注册，目前仅支持Gin/Chi/Echo/Hertz/Iris引擎； 函数返回值至多只有一个，可以没有，也可以有一个，限定类型为Go struct类型； 函数中的最后一个参数和返回值，如果有的话，限定类型为Go struct类型，并且可以说与接口定义的同一个包中的结构体，也可以是其他包中的结构体； 如上示例，使用gin引擎样式代码生成器将生成如下代码:\ntype _binding_ interface { Bind(*gin.Context) mir.Error } type _render_ interface { Render(*gin.Context) } type _default_ interface { Bind(*gin.Context, any) mir.Error Render(*gin.Context, any, mir.Error) } type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } type User interface { _default_ // Chain provide handlers chain for gin Chain() gin.HandlersChain Login(c *gin.Context, req *LoginReq) (*LoginResp, mir.Error) Logout(c *gin.Context) mir.Error mustEmbedUnimplementedUserServant() } "},{"id":4,"href":"/mir/docs/tutorials/code-generate/","title":"代码生成","section":"使用指南","content":" 代码生成 # // file: mirc/auto/api/routes.go // Code generated by go-mir. DO NOT EDIT. // versions: // - mir v3.1.1 package routes import ( \u0026#34;net/http\u0026#34; \u0026#34;github.com/alimy/mir/v5\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) type LoginReq struct { Name string `json:\u0026#34;name\u0026#34;` Passwd string `json:\u0026#34;passwd\u0026#34;` } type LoginResp struct { JwtToken string `json:\u0026#34;jwt_token\u0026#34;` } type User interface { // Chain provide handlers chain for gin Chain() gin.HandlersChain Login(c *gin.Context, req *LoginReq) (*LoginResp, mir.Error) Logout(c *gin.Context) mir.Error mustEmbedUnimplementedUserServant() } type UserBinding interface { BindLogin(c *gin.Context) (*LoginReq, mir.Error) mustEmbedUnimplementedUserBinding() } type UserRender interface { RenderLogin(c *gin.Context, data *LoginResp, err mir.Error) RenderLogout(c *gin.Context, err mir.Error) mustEmbedUnimplementedUserRender() } // UnimplementedUserServant can be embedded to have forward compatible implementations. type UnimplementedUserServant struct { } // UnimplementedSiteBinding can be embedded to have forward compatible implementations. type UnimplementedSiteBinding struct { BindAny func(*gin.Context, any) mir.Error } // UnimplementedSiteRender can be embedded to have forward compatible implementations. type UnimplementedSiteRender struct { RenderAny func(*gin.Context, any, mir.Error) } // RegisterUserServant register User servant to gin func RegisterUserServant(e *gin.Engine, s User, b UserBinding, r UserRender) { router := e.Group(\u0026#34;v1\u0026#34;) // use chain for router middlewares := s.Chain() router.Use(middlewares...) // register routes info to router router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/login/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } req, err := b.BindLogin(c) if err != nil { r.RenderLogin(c, nil, err) } resp, err := s.Login(c, req) r.RenderLogin(c, resp, err) }) router.Handle(\u0026#34;POST\u0026#34;, \u0026#34;/logout/\u0026#34;, func(c *gin.Context) { select { case \u0026lt;-c.Request.Context().Done(): return default: } r.RenderLogout(c, s.Logout(c)) }) } func (UnimplementedUserServant) Chain() gin.HandlersChain { return nil } func (UnimplementedUserServant) Login(c *gin.Context, req *LoginReq) (*LoginResp, mir.Error) { return nil, mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) Logout(c *gin.Context) mir.Error { return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented)) } func (UnimplementedUserServant) mustEmbedUnimplementedUserServant() {} func (b UnimplementedUserBinding) BindLogin(c *gin.Context) (*LoginReq, mir.Error) { obj := new(LoginReq) err := b.BindAny(c, obj) return obj, err } func (b UnimplementedUserBinding) mustEmbedUnimplementedUserBinding() {} func (r UnimplementedUserRender) RenderLogin(c *gin.Context, data *LoginResp, err mir.Error) { r.RenderAny(c, data, err) } func (r UnimplementedUserRender) RenderLogout(c *gin.Context, err mir.Error) { r.RenderAny(c, nil, err) } func (r UnimplementedUserRender) mustEmbedUnimplementedUserRender() {} "},{"id":5,"href":"/mir/docs/tutorials/servant-implement/","title":"接口实现","section":"使用指南","content":" 接口实现 # // file: servants/user.go package servants import ( \u0026#34;github.com/alimy/mir-example/v4/mirc/auto/api\u0026#34; ) type userSrv struct { api.UnimplementedUserServant } type userBinding struct { *api.UnimplementedUserBinding } type userRender struct { *api.UnimplementedUserRender } func newUserSrv() api.Site { return \u0026amp;userSrv{} } func newUserBinding() api.SiteBinding { return \u0026amp;siteBinding{ UnimplementedSiteBinding: \u0026amp;api.UnimplementedSiteBinding{ BindAny: bindAny, }, } } func newUserRender() api.SiteRender { return \u0026amp;siteRender{ UnimplementedSiteRender: \u0026amp;api.UnimplementedSiteRender{ RenderAny: renderAny, }, } } func bindAny(c *gin.Context, obj any) mir.Error { if err != c.ShouldBind(obj); err != nil { return mir.NewError(http.StatusBadRequest, err) } return nil } func renderAny(c *gin.Context, data any, err mir.Error) { if err == nil { c.JSON(http.StatusOK, data) } else { c.JSON(err.StatusCode(), err.Error()) } } "},{"id":6,"href":"/mir/docs/tutorials/servant-register/","title":"服务注册","section":"使用指南","content":" 服务注册 # // file: servants/servants.go package servants import ( \u0026#34;github.com/alimy/mir-example/v4/mirc/auto/api\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // RegisterServants register all the servants to gin.Engine func RegisterServants(e *gin.Engine) { api.RegisterUserServant(e, newUserSrv(), newUserBinding(), newUserRender()) // TODO: some other servant to register } "},{"id":7,"href":"/mir/docs/tutorials/app-start/","title":"程序启动","section":"使用指南","content":" 程序启动: # // file: main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/alimy/mir-example/v4/servants\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) func main() { e := gin.Default() // register servants to gin servants.RegisterServants(e) // start servant service if err := e.Run(); err != nil { log.Fatal(err) } } "},{"id":8,"href":"/mir/docs/quck-start/projects-use-go-mir/","title":"使用go-mir的项目","section":"快速开始","content":" 使用go-mir的项目 # examples - 本项目自带的demo，主要演示了如何使用 Mir快速进行RESTful API的后端开发。 paopao-ce - 一个清新文艺的微社区，提供类似Twiter/微博的推文分享服务。 "}]