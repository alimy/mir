// Code generated by go-mir. DO NOT EDIT.
// versions:
// - mir {{ .VerInfo.MirVer }}

package {{ .PkgName }}

import (
	{{if .IsUseRequestContext }}"context"{{end}}
    "net/http"

    "github.com/alimy/mir/v5"
    {{if notEmptyStr .EngineInfo.PkgName }}gin "{{ .EngineInfo.PkgName }}{{else}}"github.com/gin-gonic/gin{{end}}"
	{{ declareImports .Imports }}
)
{{- if .DeclareCoreInterface }}
type _default_ interface {
	Bind(*gin.Context, any) error
	{{- if .Default.IsBindingByName }}
	BindByName(string, *gin.Context, any) error
	{{- end }}
	{{- if  .Default.IsBindingById }}
	{{- range .Default.BindingIds }}
	Bind{{ . }}(*gin.Context, any) error
	{{- end }}
	{{- end }}
	Render(*gin.Context, any, error)
	{{- if .Default.IsRenderByName }}
	RenderByName(string, *gin.Context, any, error)
	{{- end }}
	{{- if .Default.IsRenderById }}
	{{- range .Default.RenderIds }}
	Render{{ . }}(*gin.Context, any, error)
	{{- end }}
	{{- end }}
}
{{- end }}

{{ declareTypes .InOuts .PkgPath .Imports }}

{{if notEmptyStr .Comment }}// {{.Comment}}{{end}}
type {{.TypeName}} interface {
	_default_

{{if notEmptyStr .Chain }}// Chain provide handlers chain for gin
    {{.Chain}}() gin.HandlersChain
{{end}}
{{range .Fields}}    {{if .JustUseContext }}{{ .MethodName}}(*gin.Context){{else}}{{.MethodName}}({{if .IsUseRequestContext }}context.Context{{if notEmptyStr .InName }}, {{end}}{{end}}{{if .IsUseContext }}*gin.Context{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName }}*{{ .InName }}{{end}}) {{if notEmptyStr .OutName }}(*{{ .OutName}}, error){{else}}error{{end}}{{end}}
{{end}}

    mustEmbedUnimplemented{{.TypeName}}Servant()
}
{{if .IsUseFieldChain }}
type {{.TypeName}}Chain interface {
{{range .ChainFields }}    Chain{{.MethodName}}() gin.HandlersChain
{{end}}

	mustEmbedUnimplemented{{.TypeName}}Chain()
}
{{end}}

// Register{{.TypeName}}Servant register {{.TypeName}} servant to gin
func Register{{.TypeName}}Servant(e *gin.Engine, s {{.TypeName}}{{if .IsUseFieldChain }},  m ...{{.TypeName}}Chain{{end}}) {
{{- if .IsUseFieldChain -}}
	var cc {{.TypeName}}Chain
	if len(m) > 0 {
		cc = m[0]
	} else {
		cc = &Unimplemented{{.TypeName}}Chain{}
	}
{{- end}}
{{if notEmptyStr .Group }}    router := e.Group("{{.Group}}"){{else}}    router := e{{end}}
{{if notEmptyStr .Chain }}    // use chain for router
    middlewares := s.{{.Chain}}()
    router.Use(middlewares...)
{{end}}
    // register routes info to router
{{range .Fields}}{{if .NotHttpAny }}    router.Handle("{{.HttpMethod}}", "{{.Path}}", {{if .IsFieldChain }}append(cc.Chain{{.MethodName}}(), {{end}}{{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *gin.Context) {
	{{- if $.WatchCtxDone }}
		select {
		case <- c.Request.Context().Done():
			return
		default:
		}
	{{end -}}
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsPrecheckIn -}}
	if err := req.Precheck(c); err != nil {
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	{{end -}}
	{{if .IsBindIn -}}
	if err := req.Bind(c); err != nil {
	{{- else -}}
	if err := {{if .IsUseNamedBinding }}{{if .UseBindingById}}s.Bind{{.BindingId}}({{else}}s.BindByName("{{.BindingName}}",{{end}} c, req){{else}}s.Bind(c, req){{end}}; err != nil {
	{{- end }}
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	{{- end }}
	{{if .IsVerifyIn -}}
	if err := req.Verify(); err != nil {
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	{{end -}}
	{{if .IsAdjustIn -}}
	req.Adjust()
	{{end -}}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseRequestContext }}c.Request.Context(){{if notEmptyStr .InName }}, {{end}}{{end}}{{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName }}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	resp.Render(c)
	{{- else -}}
	{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, resp, err)
	{{- end }}
	{{- else -}}
	{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, s.{{.MethodName}}({{if .IsUseRequestContext }}c.Request.Context(){{if notEmptyStr .InName }}, {{end}}{{end}}{{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	}{{end}}{{if .IsFieldChain }})...{{end}})
	{{else if .JustHttpAny}}    router.Any("{{.Path}}", {{if .IsFieldChain }}append(cc.Chain{{.MethodName}}(), {{end}}{{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *gin.Context) {
	{{- if $.WatchCtxDone }}
		select {
		case <- c.Request.Context().Done():
			return
		default:
		}
	{{end -}}
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsPrecheckIn -}}
	if err := req.Precheck(c); err != nil {
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	{{end -}}
	{{if .IsBindIn -}}
	if err := req.Bind(c); err != nil {
	{{- else -}}
	if err := {{if .IsUseNamedBinding }}{{if .UseBindingById}}s.Bind{{.BindingId}}({{else}}s.BindByName("{{.BindingName}}",{{end}} c, req){{else}}s.Bind(c, req){{end}}; err != nil {
	{{- end }}
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	{{- end }}
	{{if .IsVerifyIn -}}
	if err := req.Verify(); err != nil {
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	{{end -}}
	{{if .IsAdjustIn -}}
	req.Adjust()
	{{end -}}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseRequestContext }}c.Request.Context(){{if notEmptyStr .InName }}, {{end}}{{end}}{{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	resp.Render(c)
	{{- else -}}
	{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, resp, err)
	{{- end }}
	{{- else -}}
	{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, s.{{.MethodName}}({{if .IsUseRequestContext }}c.Request.Context(){{if notEmptyStr .InName }}, {{end}}{{end}}{{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	}{{end}}{{if .IsFieldChain }})...{{end}})
	{{else}}{{$field := .}}    {
        	h := {{if .IsFieldChain }}append(cc.Chain{{.MethodName}}(), {{end}}{{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *gin.Context) {
			{{- if $.WatchCtxDone }}
				select {
				case <- c.Request.Context().Done():
					return
				default:
				}
			{{end -}}
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsPrecheckIn -}}
	if err := req.Precheck(c); err != nil {
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	{{end -}}
	{{if .IsBindIn -}}
	if err := req.Bind(c); err != nil {
	{{- else -}}
	if err := {{if .IsUseNamedBinding }}{{if .UseBindingById}}s.Bind{{.BindingId}}({{else}}s.BindByName("{{.BindingName}}",{{end}} c, req){{else}}s.Bind(c, req){{end}}; err != nil {
	{{- end }}
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	{{- end }}
	{{if .IsVerifyIn -}}
	if err := req.Verify(); err != nil {
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	{{end -}}
	{{if .IsAdjustIn -}}
	req.Adjust()
	{{end -}}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseRequestContext }}c.Request.Context(){{if notEmptyStr .InName }}, {{end}}{{end}}{{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, err)
		return
	}
	resp.Render(c)
	{{- else -}}
	{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, resp, err)
	{{- end }}
	{{- else -}}
	{{if .IsUseNamedRender }}{{if .UseRenderById}}s.Render{{.RenderId}}({{else}}s.RenderByName("{{.RenderName}}",{{end}} {{else}}s.Render({{end}}c, nil, s.{{.MethodName}}({{if .IsUseRequestContext }}c.Request.Context(){{if notEmptyStr .InName }}, {{end}}{{end}}{{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	}{{end}}{{if .IsFieldChain }}){{end}}
	{{range .AnyHttpMethods}}        router.Handle("{{.}}", "{{$field.Path}}", h{{if $field.IsFieldChain }}...{{end}})
	{{end}}    }
	{{end}}
{{- end -}}
}

{{ $unimplementedServant := print "Unimplemented" .TypeName "Servant" }}
// {{$unimplementedServant}} can be embedded to have forward compatible implementations.
type {{$unimplementedServant}} struct {}

{{if notEmptyStr .Chain }}
func ({{$unimplementedServant}}){{.Chain}}() gin.HandlersChain {
    return nil
}

{{end}}
{{range .Fields}}
func ({{$unimplementedServant}}){{if .JustUseContext}}{{ .MethodName}}(c *gin.Context){{else}}{{.MethodName}}({{if .IsUseRequestContext }}c context.Context{{if notEmptyStr .InName }}, {{end}}{{end}}{{if .IsUseContext }}c *gin.Context{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName }}req *{{ .InName }}{{end}}) {{if notEmptyStr .OutName }}(*{{ .OutName}}, error){{else}}error{{end}}{{end}} {
	{{if .JustUseContext -}}
		c.String(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
	{{else -}}
	return {{if notEmptyStr .OutName }}nil, {{end}}mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
	{{end -}}
}

{{end}}
func ({{$unimplementedServant}})mustEmbedUnimplemented{{.TypeName}}Servant() {}
{{ if .IsUseFieldChain }}
{{ $unimplementedChain := print "Unimplemented" .TypeName "Chain" }}
// {{$unimplementedChain}} can be embedded to have forward compatible implementations.
type {{$unimplementedChain}} struct {}

{{range .Fields}}{{if .IsFieldChain }}func (b *{{$unimplementedChain}}) Chain{{.MethodName}}() gin.HandlersChain {
	return nil
}
{{end}}
{{end}}
func (b *{{$unimplementedChain}})mustEmbedUnimplemented{{.TypeName}}Chain() {}
{{ end }}
