// Code generated by go-mir. DO NOT EDIT.
// versions:
// - mir {{ .VerInfo.MirVer }}

package {{ .PkgName }}

import (
    "net/http"

    "github.com/alimy/mir/v5"
    {{if notEmptyStr .EngineInfo.PkgName }}macaron "{{ .EngineInfo.PkgName }}{{else}}"gopkg.in/macaron.v1{{end}}"
	{{ declareImports .Imports }}
)
{{- if .DeclareCoreInterface }}
type _binding_ interface {
	Bind(*macaron.Context) mir.Error
}

type _render_ interface {
	Render(*macaron.Context)
}

type _default_ interface {
	Bind(*macaron.Context, any) mir.Error
	Render(*macaron.Context, any, mir.Error)
}
{{- end }}

{{ declareTypes .InOuts .PkgPath .Imports }}

{{if notEmptyStr .Comment }}// {{.Comment}}{{end}}
type {{.TypeName}} interface {
	_default_

{{if notEmptyStr .Chain }}// Chain provide handlers chain for macaron
    {{.Chain}}() []macaron.Handler
{{end}}
{{range .Fields}}   {{if .JustUseContext }}{{ .MethodName}}(*macaron.Context){{else}}{{.MethodName}}({{if .IsUseContext }}*macaron.Context{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName }}*{{ .InName }}{{end}}) {{if notEmptyStr .OutName }}(*{{ .OutName}}, mir.Error){{else}}mir.Error{{end}}{{end}}
{{end}}

    mustEmbedUnimplemented{{.TypeName}}Servant()
}

// Register{{.TypeName}}Servant register {{.TypeName}} servant to macaron
func Register{{.TypeName}}Servant(m *macaron.Macaron, s {{.TypeName}}) {
{{if notEmptyStr .Group }}{{if notEmptyStr .Chain }}    // use chain for router
    middlewares := s.{{.Chain}}()
    m.Group("{{.Group}}", func() {
{{range .Fields}}{{if .NotHttpAny }}    m.Handle("{{.HttpMethod}}", "{{.Path}}", []macaron.Handler{ {{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *macaron.Context) {
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsBindIn -}}
	var bv _binding_ = req
	if err := bv.Bind(c); err != nil {
	{{- else -}}
	if err := s.Bind(c, req); err != nil {
	{{- end }}
		s.Render(c, nil, err)
		return
	}
	{{- end }}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		s.Render(c, nil, err)
		return
	}
	var rv _render_ = resp
	rv.Render(c)
	{{- else -}}
	s.Render(c, resp, err)
	{{- end }}
	{{- else -}}
	s.Render(c, nil, s.{{.MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	}{{end}}})
	{{else if .JustHttpAny}}    m.Any("{{.Path}}", {{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *macaron.Context) {
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsBindIn -}}
	var bv _binding_ = req
	if err := bv.Bind(c); err != nil {
	{{- else -}}
	if err := s.Bind(c, req); err != nil {
	{{- end }}
		s.Render(c, nil, err)
		return
	}
	{{- end }}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		s.Render(c, nil, err)
		return
	}
	var rv _render_ = resp
	rv.Render(c)
	{{- else -}}
	s.Render(c, resp, err)
	{{- end }}
	{{- else -}}
	s.Render(c, nil, s.{{.MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	}{{end}})
	{{else}}{{$field := .}}    {
        h := {{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *macaron.Context) {
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsBindIn -}}
	var bv _binding_ = req
	if err := bv.Bind(c); err != nil {
	{{- else -}}
	if err := s.Bind(c, req); err != nil {
	{{- end }}
		s.Render(c, nil, err)
		return
	}
	{{- end }}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		s.Render(c, nil, err)
		return
	}
	var rv _render_ = resp
	rv.Render(c)
	{{- else -}}
	s.Render(c, resp, err)
	{{- end }}
	{{- else -}}
	s.Render(c, nil, s.{{.MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	    }{{end}}
		{{range .AnyHttpMethods}}    m.Handle("{{.}}", "{{$field.Path}}", []macaron.Handler{h})
		{{end}}}{{end}}
{{end}}}, middlewares...){{else}} m.Group("{{.Group}}", func() {
{{range .Fields}}{{if .NotHttpAny }}    m.Handle("{{.HttpMethod}}", "{{.Path}}", []macaron.Handler{ {{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *macaron.Context) {
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsBindIn -}}
	var bv _binding_ = req
	if err := bv.Bind(c); err != nil {
	{{- else -}}
	if err := s.Bind(c, req); err != nil {
	{{- end }}
		s.Render(c, nil, err)
		return
	}
	{{- end }}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		s.Render(c, nil, err)
		return
	}
	var rv _render_ = resp
	rv.Render(c)
	{{- else -}}
	s.Render(c, resp, err)
	{{- end }}
	{{- else -}}
	s.Render(c, nil, s.{{.MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	}{{end}}})
{{else if .JustHttpAny}}    m.Any("{{.Path}}",  {{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *macaron.Context) {
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsBindIn -}}
	var bv _binding_ = req
	if err := bv.Bind(c); err != nil {
	{{- else -}}
	if err := s.Bind(c, req); err != nil {
	{{- end }}
		s.Render(c, nil, err)
		return
	}
	{{- end }}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		s.Render(c, nil, err)
		return
	}
	var rv _render_ = resp
	rv.Render(c)
	{{- else -}}
	s.Render(c, resp, err)
	{{- end }}
	{{- else -}}
	s.Render(c, nil, s.{{.MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	}{{end}})
	{{else}}{{$field := .}}    {
        h := {{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *macaron.Context) {
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsBindIn -}}
	var bv _binding_ = req
	if err := bv.Bind(c); err != nil {
	{{- else -}}
	if err := s.Bind(c, req); err != nil {
	{{- end }}
		s.Render(c, nil, err)
		return
	}
	{{- end }}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		s.Render(c, nil, err)
		return
	}
	var rv _render_ = resp
	rv.Render(c)
	{{- else -}}
	s.Render(c, resp, err)
	{{- end }}
	{{- else -}}
	s.Render(c, nil, s.{{.MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	    }{{end}}
		{{range .AnyHttpMethods}}    m.Handle("{{.}}", "{{$field.Path}}", []macaron.Handler{h})
		{{end}}}{{end}}
{{end}}}){{end}}{{else}}{{if notEmptyStr .Chain }}    // use chain for router
    middlewares := s.{{.Chain}}()
    for _, middleware := range middlewares {
        m.Use(middleware)
    }{{end}}

{{range .Fields}}{{if .NotHttpAny }}    m.Handle("{{.HttpMethod}}", "{{.Path}}", []macaron.Handler{ {{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *macaron.Context) {
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsBindIn -}}
	var bv _binding_ = req
	if err := bv.Bind(c); err != nil {
	{{- else -}}
	if err := s.Bind(c, req); err != nil {
	{{- end }}
		s.Render(c, nil, err)
		return
	}
	{{- end }}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		s.Render(c, nil, err)
		return
	}
	var rv _render_ = resp
	rv.Render(c)
	{{- else -}}
	s.Render(c, resp, err)
	{{- end }}
	{{- else -}}
	s.Render(c, nil, s.{{.MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	}{{end}}})
	{{else if .JustHttpAny}}    m.Any("{{.Path}}", {{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *macaron.Context) {
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsBindIn -}}
	var bv _binding_ = req
	if err := bv.Bind(c); err != nil {
	{{- else -}}
	if err := s.Bind(c, req); err != nil {
	{{- end }}
		s.Render(c, nil, err)
		return
	}
	{{- end }}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		s.Render(c, nil, err)
		return
	}
	var rv _render_ = resp
	rv.Render(c)
	{{- else -}}
	s.Render(c, resp, err)
	{{- end }}
	{{- else -}}
	s.Render(c, nil, s.{{.MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	}{{end}})
	{{else}}{{$field := .}}    {
        h := {{if .JustUseContext}}s.{{ .MethodName}}{{else}}func(c *macaron.Context) {
	{{if notEmptyStr .InName -}}
	req := new({{.InName}})
	{{if .IsBindIn -}}
	var bv _binding_ = req
	if err := bv.Bind(c); err != nil {
	{{- else -}}
	if err := s.Bind(c, req); err != nil {
	{{- end }}
		s.Render(c, nil, err)
		return
	}
	{{- end }}
	{{if notEmptyStr .OutName -}}
	resp, err := s.{{ .MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}})
	{{if .IsRenderOut -}}
	if err != nil {
		s.Render(c, nil, err)
		return
	}
	var rv _render_ = resp
	rv.Render(c)
	{{- else -}}
	s.Render(c, resp, err)
	{{- end }}
	{{- else -}}
	s.Render(c, nil, s.{{.MethodName}}({{if .IsUseContext }}c{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName}}req{{end}}))
	{{- end }}
	    }{{end}}
		{{range .AnyHttpMethods}}    m.Handle("{{.}}", "{{$field.Path}}", []macaron.Handler{h})
		{{end}}}
	{{end}}
{{end}}
{{- end -}}
}

{{ $unimplementedServant := print "Unimplemented" .TypeName "Servant" }}
// {{$unimplementedServant}} can be embedded to have forward compatible implementations.
type {{$unimplementedServant}} struct {}

{{if notEmptyStr .Chain }}
func ({{$unimplementedServant}}){{.Chain}}() []macaron.Handler {
    return nil
}

{{end}}
{{range .Fields}}
func ({{$unimplementedServant}}){{if .JustUseContext }}{{ .MethodName}}(c *macaron.Context){{else}}{{.MethodName}}({{if .IsUseContext }}c *macaron.Context{{if notEmptyStr .InName }}, {{end}}{{end}}{{if notEmptyStr .InName }}req *{{ .InName }}{{end}}) {{if notEmptyStr .OutName }}(*{{ .OutName}}, mir.Error){{else}}mir.Error{{end}}{{end}} {
	{{if .JustUseContext -}}
		c.Resp.WriteHeader(http.StatusNotImplemented)
		c.Resp.Write([]byte("method not implemented"))
	{{else -}}
	return {{if notEmptyStr .OutName }}nil, {{end}}mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
	{{end -}}
}

{{end}}
func ({{$unimplementedServant}})mustEmbedUnimplemented{{.TypeName}}Servant() {}
