// Code generated by go-mir. DO NOT EDIT.
// versions:
// - mir {{ .VerInfo.MirVer }}

package {{ .PkgName }}

import (
    "net/http"

    "github.com/alimy/mir/v4"
    {{if notEmptyStr .EngineInfo.PkgName }}macaron "{{ .EngineInfo.PkgName }}{{else}}"gopkg.in/macaron.v1{{end}}"
	{{ declareImports .Imports }}
)

{{ declareTypes .InOuts .PkgPath .Imports }}

{{if notEmptyStr .Comment }}// {{.Comment}}{{end}}
type {{.TypeName}} interface {
{{if notEmptyStr .Chain }}// Chain provide handlers chain for macaron
    {{.Chain}}() []macaron.Handler
{{end}}
{{range .Fields}}    {{.MethodName}}({{if notEmptyStr .InName }}*{{ .InName }}{{end}}) {{if notEmptyStr .OutName }}(*{{ .OutName}}, mir.Error){{else}}mir.Error{{end}}
{{end}}

    mustEmbedUnimplemented{{.TypeName}}Servant()
}
{{if .IsUseBinding }}
type {{.TypeName}}Binding interface {
{{range .BindingFields }}    Bind{{.MethodName}}(*macaron.Context) (*{{ .InName }}, mir.Error)
{{end}}

	mustEmbedUnimplemented{{.TypeName}}Binding()
}
{{end}}

type {{.TypeName}}Render interface {
{{range .Fields}}    {{if notEmptyStr .OutName }}Render{{.MethodName}}(*macaron.Context, *{{ .OutName }}, mir.Error){{else}}Render{{.MethodName}}(*macaron.Context, mir.Error){{end}}
{{end}}
	
	mustEmbedUnimplemented{{.TypeName}}Render()
}

// Register{{.TypeName}}Servant register {{.TypeName}} servant to macaron
func Register{{.TypeName}}Servant(m *macaron.Macaron, s {{.TypeName}}{{if .IsUseBinding }},  b {{.TypeName}}Binding{{end}}, r {{.TypeName}}Render ) {
{{if notEmptyStr .Group }}{{if notEmptyStr .Chain }}    // use chain for router
    middlewares := s.{{.Chain}}()
    m.Group("{{.Group}}", func() {
{{range .Fields}}{{if .NotHttpAny }}    m.Handle("{{.HttpMethod}}", "{{.Path}}", []macaron.Handler{func(c *macaron.Context) {
		{{if notEmptyStr .InName }}req, err := b.Bind{{.MethodName}}(c)
		if err != nil {
			{{if notEmptyStr .OutName }}r.Render{{.MethodName}}(c, nil, err){{else}}r.Render{{.MethodName}}(c, err){{end}}
			return
		}
		{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}(req)
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}(req)){{end}}{{else}}{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}()
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}()){{end}}{{end}}
	}})
	{{else if .JustHttpAny}}    m.Any("{{.Path}}", func(c *macaron.Context) {
		{{if notEmptyStr .InName }}req, err := b.Bind{{.MethodName}}(c)
		if err != nil {
			{{if notEmptyStr .OutName }}r.Render{{.MethodName}}(c, nil, err){{else}}r.Render{{.MethodName}}(c, err){{end}}
			return
		}
		{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}(req)
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}(req)){{end}}{{else}}{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}()
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}()){{end}}{{end}}
	})
	{{else}}{{$field := .}}    {
        h := func(c *macaron.Context) {
		    {{if notEmptyStr .InName }}req, err := b.Bind{{.MethodName}}(c)
		    if err != nil {
			    {{if notEmptyStr .OutName }}r.Render{{.MethodName}}(c, nil, err){{else}}r.Render{{.MethodName}}(c, err){{end}}
				return
		    }
		    {{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}(req)
		    r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}(req)){{end}}{{else}}{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}()
		    r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}()){{end}}{{end}}
	    }
		{{range .AnyHttpMethods}}    m.Handle("{{.}}", "{{$field.Path}}", []macaron.Handler{h})
		{{end}}}{{end}}
{{end}}}, middlewares...){{else}} m.Group("{{.Group}}", func() {
{{range .Fields}}{{if .NotHttpAny }}    m.Handle("{{.HttpMethod}}", "{{.Path}}", []macaron.Handler{func(c *macaron.Context) {
		{{if notEmptyStr .InName }}req, err := b.Bind{{.MethodName}}(c)
		if err != nil {
			{{if notEmptyStr .OutName }}r.Render{{.MethodName}}(c, nil, err){{else}}r.Render{{.MethodName}}(c, err){{end}}
			return
		}
		{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}(req)
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}(req)){{end}}{{else}}{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}()
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}()){{end}}{{end}}
	}})
{{else if .JustHttpAny}}    m.Any("{{.Path}}",  func(c *macaron.Context) {
		{{if notEmptyStr .InName }}req, err := b.Bind{{.MethodName}}(c)
		if err != nil {
			{{if notEmptyStr .OutName }}r.Render{{.MethodName}}(c, nil, err){{else}}r.Render{{.MethodName}}(c, err){{end}}
			return
		}
		{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}(req)
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}(req)){{end}}{{else}}{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}()
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}()){{end}}{{end}}
	})
	{{else}}{{$field := .}}    {
        h := func(c *macaron.Context) {
		    {{if notEmptyStr .InName }}req, err := b.Bind{{.MethodName}}(c)
		    if err != nil {
			    {{if notEmptyStr .OutName }}r.Render{{.MethodName}}(c, nil, err){{else}}r.Render{{.MethodName}}(c, err){{end}}
				return
		    }
		    {{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}(req)
		    r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}(req)){{end}}{{else}}{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}()
		    r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}()){{end}}{{end}}
	    }
		{{range .AnyHttpMethods}}    m.Handle("{{.}}", "{{$field.Path}}", []macaron.Handler{h})
		{{end}}}{{end}}
{{end}}}){{end}}{{else}}{{if notEmptyStr .Chain }}    // use chain for router
    middlewares := s.{{.Chain}}()
    for _, middleware := range middlewares {
        m.Use(middleware)
    }{{end}}

{{range .Fields}}{{if .NotHttpAny }}    m.Handle("{{.HttpMethod}}", "{{.Path}}", []macaron.Handler{func(c *macaron.Context) {
		{{if notEmptyStr .InName }}req, err := b.Bind{{.MethodName}}(c)
		if err != nil {
			{{if notEmptyStr .OutName }}r.Render{{.MethodName}}(c, nil, err){{else}}r.Render{{.MethodName}}(c, err){{end}}
			return
		}
		{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}(req)
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}(req)){{end}}{{else}}{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}()
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}()){{end}}{{end}}
	}})
	{{else if .JustHttpAny}}    m.Any("{{.Path}}", func(c *macaron.Context) {
		{{if notEmptyStr .InName }}req, err := b.Bind{{.MethodName}}(c)
		if err != nil {
			{{if notEmptyStr .OutName }}r.Render{{.MethodName}}(c, nil, err){{else}}r.Render{{.MethodName}}(c, err){{end}}
			return
		}
		{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}(req)
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}(req)){{end}}{{else}}{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}()
		r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}()){{end}}{{end}}
	})
	{{else}}{{$field := .}}    {
        h := func(c *macaron.Context) {
		    {{if notEmptyStr .InName }}req, err := b.Bind{{.MethodName}}(c)
		    if err != nil {
			    {{if notEmptyStr .OutName }}r.Render{{.MethodName}}(c, nil, err){{else}}r.Render{{.MethodName}}(c, err){{end}}
				return
		    }
		    {{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}(req)
		    r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}(req)){{end}}{{else}}{{if notEmptyStr .OutName}}resp, err := s.{{.MethodName}}()
		    r.Render{{.MethodName}}(c, resp, err){{else}}r.Render{{.MethodName}}(c, s.{{.MethodName}}()){{end}}{{end}}
	    }
		{{range .AnyHttpMethods}}    m.Handle("{{.}}", "{{$field.Path}}", []macaron.Handler{h})
		{{end}}}
	{{end}}
{{end}}{{end}}}

{{ $unimplementedServant := print "Unimplemented" .TypeName "Servant" }}
// {{$unimplementedServant}} can be embedded to have forward compatible implementations.
type {{$unimplementedServant}} struct {
}

{{if notEmptyStr .Chain }}
func ({{$unimplementedServant}}){{.Chain}}() []macaron.Handler {
    return nil
}

{{end}}
{{range .Fields}}
func ({{$unimplementedServant}}){{.MethodName}}({{if notEmptyStr .InName }}req *{{ .InName }}{{end}}) {{if notEmptyStr .OutName }}(*{{ .OutName}}, mir.Error){{else}}mir.Error{{end}} {
	return {{if notEmptyStr .OutName }}nil, {{end}}mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

{{end}}
func ({{$unimplementedServant}})mustEmbedUnimplemented{{.TypeName}}Servant() {}

{{ $unimplementedRender := print "Unimplemented" .TypeName "Render" }}
// {{$unimplementedRender}} can be embedded to have forward compatible implementations.
type {{$unimplementedRender}} struct {
	RenderAny func(*macaron.Context, any, mir.Error)
}

{{range .Fields}}
func (r *{{$unimplementedRender}}) Render{{.MethodName}}(c *macaron.Context{{if notEmptyStr .OutName }}, data *{{ .OutName }}{{end}}, err mir.Error) {
	{{if notEmptyStr .OutName}}r.RenderAny(c, data, err){{else}}r.RenderAny(c, nil, err){{end}}
}

{{end}}
func (r *{{$unimplementedRender}})mustEmbedUnimplemented{{.TypeName}}Render() {}
{{if .IsUseBinding }}
{{ $unimplementedBinding := print "Unimplemented" .TypeName "Binding" }}
// {{$unimplementedBinding}} can be embedded to have forward compatible implementations.
type {{$unimplementedBinding}} struct {
	BindAny func(*macaron.Context, any) mir.Error
}

{{range .Fields}}{{if notEmptyStr .InName }}func (b *{{$unimplementedBinding}}) Bind{{.MethodName}}(c *macaron.Context) (*{{ .InName }}, mir.Error) {
	obj := new({{ .InName }})
	err := b.BindAny(c, obj)
	return obj, err
}
{{end}}
{{end}}
func (b *{{$unimplementedBinding}})mustEmbedUnimplemented{{.TypeName}}Binding() {}
{{end}}
