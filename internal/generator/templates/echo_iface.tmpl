// Code generated by go-mir. DO NOT EDIT.

package {{ .PkgName }}

import (
    "net/http"

    echo "{{if notEmptyStr .EngineInfo.PkgName }}{{ .EngineInfo.PkgName }}{{else}}github.com/labstack/echo/v4{{end}}"
)

{{if notEmptyStr .Comment }}// {{.Comment}}{{end}}
type {{.TypeName}} interface {
{{if notEmptyStr .Chain }}// Chain provide handlers chain for echo
    {{.Chain}}() []echo.MiddlewareFunc
{{end}}
{{range .Fields}}{{if notEmptyStr .Comment }}    // {{.Comment}}
    {{.MethodName}}(echo.Context) error{{else}}    {{.MethodName}}(echo.Context) error{{end}}
{{end}}
}

// Register{{.TypeName}}Servant register {{.TypeName}} servant to echo
func Register{{.TypeName}}Servant(e *echo.Echo, s {{.TypeName}}) {
{{if notEmptyStr .Group }}    g := e.Group("{{.Group}}"){{else}}    g := e{{end}}
{{if notEmptyStr .Chain }}    // use chain for router
    middlewares := s.{{.Chain}}()
    g.Use(middlewares...)
{{end}}
    // register routes info to router
{{range .Fields}}{{if notHttpAny .HttpMethod }}    g.Add("{{.HttpMethod}}", "{{.Path}}", s.{{.MethodName}}){{else}}    g.Any("{{.Path}}", s.{{.MethodName}}){{end}}
{{end}}}

{{ $unimplementedServant := print "Unimplemented" .TypeName "Servant" }}
// {{$unimplementedServant}} can be embedded to have forward compatible implementations.
type {{$unimplementedServant}} struct {
}

{{if notEmptyStr .Chain }}
func (*{{$unimplementedServant}}){{.Chain}}() []echo.MiddlewareFunc {
    return nil
}

{{end}}
{{range .Fields}}
func (*{{$unimplementedServant}}){{.MethodName}}(c echo.Context) error {
    c.String(http.StatusNotImplemented, "method {{.MethodName}} not implemented")
    return nil
}

{{end}}

