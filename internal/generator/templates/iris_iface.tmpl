// Code generated by go-mir. DO NOT EDIT.

package {{ .PkgName }}

import (
    "net/http"

    "{{if notEmptyStr .EngineInfo.PkgName }}{{ .EngineInfo.PkgName }}/context{{else}}github.com/kataras/iris/v12/context{{end}}"

    iris "{{if notEmptyStr .EngineInfo.PkgName }}{{ .EngineInfo.PkgName }}{{else}}github.com/kataras/iris/v12{{end}}"
)

{{if notEmptyStr .Comment }}// {{.Comment}}{{end}}
type {{.TypeName}} interface {
{{if notEmptyStr .Chain }}// Chain provide handlers chain for iris
    {{.Chain}}() context.Handlers
{{end}}
{{range .Fields}}{{if notEmptyStr .Comment }}    // {{.Comment}}
    {{.MethodName}}(context.Context){{else}}    {{.MethodName}}(context.Context){{end}}
{{end}}

    mustEmbedUnimplemented{{.TypeName}}Servant()
}

// Register{{.TypeName}}Servant register {{.TypeName}} servant to iris
func Register{{.TypeName}}Servant(app *iris.Application, s {{.TypeName}}) {
{{if notEmptyStr .Group }}    p := app.Party("{{.Group}}"){{else}}    p := app{{end}}
{{if notEmptyStr .Chain }}    // use chain for party
    middlewares := s.{{.Chain}}()
    p.Use(middlewares...)
{{end}}
    // register routes info to party
{{range .Fields}}{{if .NotHttpAny}}    p.Handle("{{.HttpMethod}}", "{{.Path}}", s.{{.MethodName}}){{else if .JustHttpAny}}    p.Any("{{.Path}}", s.{{.MethodName}}){{else}}{{$field := .}}{{range .AnyHttpMethods}}    p.Handle("{{.}}", "{{$field.Path}}", s.{{$field.MethodName}})
{{end}}{{end}}
{{end}}}

{{ $unimplementedServant := print "Unimplemented" .TypeName "Servant" }}
// {{$unimplementedServant}} can be embedded to have forward compatible implementations.
type {{$unimplementedServant}} struct {
}

{{if notEmptyStr .Chain }}
func ({{$unimplementedServant}}){{.Chain}}() context.Handlers {
    return nil
}

{{end}}
{{range .Fields}}
func ({{$unimplementedServant}}){{.MethodName}}(c context.Context) {
    c.StatusCode(http.StatusNotImplemented)
    c.WriteString("method {{.MethodName}} not implemented")
}

{{end}}
func ({{$unimplementedServant}})mustEmbedUnimplemented{{.TypeName}}Servant() {}
